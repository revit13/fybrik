/*
Consolidate Services

Description of all APIs

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapiclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// RepositoryServiceApiService RepositoryServiceApi service
type RepositoryServiceApiService service

type ApiRepositoryServiceCreateRepositoryRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	body *V1alpha1Repository
	upsert *bool
	credsOnly *bool
}

// Repository definition
func (r ApiRepositoryServiceCreateRepositoryRequest) Body(body V1alpha1Repository) ApiRepositoryServiceCreateRepositoryRequest {
	r.body = &body
	return r
}
// Whether to create in upsert mode.
func (r ApiRepositoryServiceCreateRepositoryRequest) Upsert(upsert bool) ApiRepositoryServiceCreateRepositoryRequest {
	r.upsert = &upsert
	return r
}
// Whether to operate on credential set instead of repository.
func (r ApiRepositoryServiceCreateRepositoryRequest) CredsOnly(credsOnly bool) ApiRepositoryServiceCreateRepositoryRequest {
	r.credsOnly = &credsOnly
	return r
}

func (r ApiRepositoryServiceCreateRepositoryRequest) Execute() (V1alpha1Repository, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceCreateRepositoryExecute(r)
}

/*
RepositoryServiceCreateRepository CreateRepository creates a new repository configuration

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRepositoryServiceCreateRepositoryRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceCreateRepository(ctx _context.Context) ApiRepositoryServiceCreateRepositoryRequest {
	return ApiRepositoryServiceCreateRepositoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1alpha1Repository
func (a *RepositoryServiceApiService) RepositoryServiceCreateRepositoryExecute(r ApiRepositoryServiceCreateRepositoryRequest) (V1alpha1Repository, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceCreateRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.upsert != nil {
		localVarQueryParams.Add("upsert", parameterToString(*r.upsert, ""))
	}
	if r.credsOnly != nil {
		localVarQueryParams.Add("credsOnly", parameterToString(*r.credsOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceDeleteRepositoryRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repo string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceDeleteRepositoryRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceDeleteRepositoryRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceDeleteRepositoryRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceDeleteRepositoryExecute(r)
}

/*
RepositoryServiceDeleteRepository DeleteRepository deletes a repository from the configuration

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repo Repo URL for query
 @return ApiRepositoryServiceDeleteRepositoryRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceDeleteRepository(ctx _context.Context, repo string) ApiRepositoryServiceDeleteRepositoryRequest {
	return ApiRepositoryServiceDeleteRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repo: repo,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RepositoryServiceApiService) RepositoryServiceDeleteRepositoryExecute(r ApiRepositoryServiceDeleteRepositoryRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceDeleteRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", _neturl.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.forceRefresh != nil {
		localVarQueryParams.Add("forceRefresh", parameterToString(*r.forceRefresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceGetRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repo string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceGetRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceGetRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceGetRequest) Execute() (V1alpha1Repository, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceGetExecute(r)
}

/*
RepositoryServiceGet Get returns a repository or its credentials

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repo Repo URL for query
 @return ApiRepositoryServiceGetRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceGet(ctx _context.Context, repo string) ApiRepositoryServiceGetRequest {
	return ApiRepositoryServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		repo: repo,
	}
}

// Execute executes the request
//  @return V1alpha1Repository
func (a *RepositoryServiceApiService) RepositoryServiceGetExecute(r ApiRepositoryServiceGetRequest) (V1alpha1Repository, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", _neturl.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.forceRefresh != nil {
		localVarQueryParams.Add("forceRefresh", parameterToString(*r.forceRefresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceGetAppDetailsRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	sourceRepoURL string
	body *RepositoryRepoAppDetailsQuery
}

func (r ApiRepositoryServiceGetAppDetailsRequest) Body(body RepositoryRepoAppDetailsQuery) ApiRepositoryServiceGetAppDetailsRequest {
	r.body = &body
	return r
}

func (r ApiRepositoryServiceGetAppDetailsRequest) Execute() (RepositoryRepoAppDetailsResponse, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceGetAppDetailsExecute(r)
}

/*
RepositoryServiceGetAppDetails GetAppDetails returns application details by given path

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sourceRepoURL RepoURL is the URL to the repository (Git or Helm) that contains the application manifests
 @return ApiRepositoryServiceGetAppDetailsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceGetAppDetails(ctx _context.Context, sourceRepoURL string) ApiRepositoryServiceGetAppDetailsRequest {
	return ApiRepositoryServiceGetAppDetailsRequest{
		ApiService: a,
		ctx: ctx,
		sourceRepoURL: sourceRepoURL,
	}
}

// Execute executes the request
//  @return RepositoryRepoAppDetailsResponse
func (a *RepositoryServiceApiService) RepositoryServiceGetAppDetailsExecute(r ApiRepositoryServiceGetAppDetailsRequest) (RepositoryRepoAppDetailsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  RepositoryRepoAppDetailsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceGetAppDetails")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{source.repoURL}/appdetails"
	localVarPath = strings.Replace(localVarPath, "{"+"source.repoURL"+"}", _neturl.PathEscape(parameterToString(r.sourceRepoURL, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceGetHelmChartsRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repo string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceGetHelmChartsRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceGetHelmChartsRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceGetHelmChartsRequest) Execute() (RepositoryHelmChartsResponse, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceGetHelmChartsExecute(r)
}

/*
RepositoryServiceGetHelmCharts GetHelmCharts returns list of helm charts in the specified repository

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repo Repo URL for query
 @return ApiRepositoryServiceGetHelmChartsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceGetHelmCharts(ctx _context.Context, repo string) ApiRepositoryServiceGetHelmChartsRequest {
	return ApiRepositoryServiceGetHelmChartsRequest{
		ApiService: a,
		ctx: ctx,
		repo: repo,
	}
}

// Execute executes the request
//  @return RepositoryHelmChartsResponse
func (a *RepositoryServiceApiService) RepositoryServiceGetHelmChartsExecute(r ApiRepositoryServiceGetHelmChartsRequest) (RepositoryHelmChartsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  RepositoryHelmChartsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceGetHelmCharts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/helmcharts"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", _neturl.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.forceRefresh != nil {
		localVarQueryParams.Add("forceRefresh", parameterToString(*r.forceRefresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceListAppsRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repo string
	revision *string
	appName *string
	appProject *string
}

func (r ApiRepositoryServiceListAppsRequest) Revision(revision string) ApiRepositoryServiceListAppsRequest {
	r.revision = &revision
	return r
}
func (r ApiRepositoryServiceListAppsRequest) AppName(appName string) ApiRepositoryServiceListAppsRequest {
	r.appName = &appName
	return r
}
func (r ApiRepositoryServiceListAppsRequest) AppProject(appProject string) ApiRepositoryServiceListAppsRequest {
	r.appProject = &appProject
	return r
}

func (r ApiRepositoryServiceListAppsRequest) Execute() (RepositoryRepoAppsResponse, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceListAppsExecute(r)
}

/*
RepositoryServiceListApps ListApps returns list of apps in the repo

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repo
 @return ApiRepositoryServiceListAppsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceListApps(ctx _context.Context, repo string) ApiRepositoryServiceListAppsRequest {
	return ApiRepositoryServiceListAppsRequest{
		ApiService: a,
		ctx: ctx,
		repo: repo,
	}
}

// Execute executes the request
//  @return RepositoryRepoAppsResponse
func (a *RepositoryServiceApiService) RepositoryServiceListAppsExecute(r ApiRepositoryServiceListAppsRequest) (RepositoryRepoAppsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  RepositoryRepoAppsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceListApps")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", _neturl.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.revision != nil {
		localVarQueryParams.Add("revision", parameterToString(*r.revision, ""))
	}
	if r.appName != nil {
		localVarQueryParams.Add("appName", parameterToString(*r.appName, ""))
	}
	if r.appProject != nil {
		localVarQueryParams.Add("appProject", parameterToString(*r.appProject, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceListRefsRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repo string
	forceRefresh *bool
}

// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceListRefsRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceListRefsRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceListRefsRequest) Execute() (RepositoryRefs, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceListRefsExecute(r)
}

/*
RepositoryServiceListRefs Method for RepositoryServiceListRefs

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repo Repo URL for query
 @return ApiRepositoryServiceListRefsRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceListRefs(ctx _context.Context, repo string) ApiRepositoryServiceListRefsRequest {
	return ApiRepositoryServiceListRefsRequest{
		ApiService: a,
		ctx: ctx,
		repo: repo,
	}
}

// Execute executes the request
//  @return RepositoryRefs
func (a *RepositoryServiceApiService) RepositoryServiceListRefsExecute(r ApiRepositoryServiceListRefsRequest) (RepositoryRefs, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  RepositoryRefs
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceListRefs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/refs"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", _neturl.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.forceRefresh != nil {
		localVarQueryParams.Add("forceRefresh", parameterToString(*r.forceRefresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceListRepositoriesRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repo *string
	forceRefresh *bool
}

// Repo URL for query.
func (r ApiRepositoryServiceListRepositoriesRequest) Repo(repo string) ApiRepositoryServiceListRepositoriesRequest {
	r.repo = &repo
	return r
}
// Whether to force a cache refresh on repo&#39;s connection state.
func (r ApiRepositoryServiceListRepositoriesRequest) ForceRefresh(forceRefresh bool) ApiRepositoryServiceListRepositoriesRequest {
	r.forceRefresh = &forceRefresh
	return r
}

func (r ApiRepositoryServiceListRepositoriesRequest) Execute() (V1alpha1RepositoryList, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceListRepositoriesExecute(r)
}

/*
RepositoryServiceListRepositories ListRepositories gets a list of all configured repositories

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRepositoryServiceListRepositoriesRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceListRepositories(ctx _context.Context) ApiRepositoryServiceListRepositoriesRequest {
	return ApiRepositoryServiceListRepositoriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1alpha1RepositoryList
func (a *RepositoryServiceApiService) RepositoryServiceListRepositoriesExecute(r ApiRepositoryServiceListRepositoriesRequest) (V1alpha1RepositoryList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1RepositoryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceListRepositories")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.repo != nil {
		localVarQueryParams.Add("repo", parameterToString(*r.repo, ""))
	}
	if r.forceRefresh != nil {
		localVarQueryParams.Add("forceRefresh", parameterToString(*r.forceRefresh, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceUpdateRepositoryRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repoRepo string
	body *V1alpha1Repository
}

func (r ApiRepositoryServiceUpdateRepositoryRequest) Body(body V1alpha1Repository) ApiRepositoryServiceUpdateRepositoryRequest {
	r.body = &body
	return r
}

func (r ApiRepositoryServiceUpdateRepositoryRequest) Execute() (V1alpha1Repository, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceUpdateRepositoryExecute(r)
}

/*
RepositoryServiceUpdateRepository UpdateRepository updates a repository configuration

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repoRepo Repo contains the URL to the remote repository
 @return ApiRepositoryServiceUpdateRepositoryRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceUpdateRepository(ctx _context.Context, repoRepo string) ApiRepositoryServiceUpdateRepositoryRequest {
	return ApiRepositoryServiceUpdateRepositoryRequest{
		ApiService: a,
		ctx: ctx,
		repoRepo: repoRepo,
	}
}

// Execute executes the request
//  @return V1alpha1Repository
func (a *RepositoryServiceApiService) RepositoryServiceUpdateRepositoryExecute(r ApiRepositoryServiceUpdateRepositoryRequest) (V1alpha1Repository, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Repository
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceUpdateRepository")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo.repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo.repo"+"}", _neturl.PathEscape(parameterToString(r.repoRepo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepositoryServiceValidateAccessRequest struct {
	ctx _context.Context
	ApiService *RepositoryServiceApiService
	repo string
	body *string
	username *string
	password *string
	sshPrivateKey *string
	insecure *bool
	tlsClientCertData *string
	tlsClientCertKey *string
	type_ *string
	name *string
	enableOci *bool
	githubAppPrivateKey *string
	githubAppID *string
	githubAppInstallationID *string
	githubAppEnterpriseBaseUrl *string
	proxy *string
	project *string
	gcpServiceAccountKey *string
	forceHttpBasicAuth *bool
}

// The URL to the repo
func (r ApiRepositoryServiceValidateAccessRequest) Body(body string) ApiRepositoryServiceValidateAccessRequest {
	r.body = &body
	return r
}
// Username for accessing repo.
func (r ApiRepositoryServiceValidateAccessRequest) Username(username string) ApiRepositoryServiceValidateAccessRequest {
	r.username = &username
	return r
}
// Password for accessing repo.
func (r ApiRepositoryServiceValidateAccessRequest) Password(password string) ApiRepositoryServiceValidateAccessRequest {
	r.password = &password
	return r
}
// Private key data for accessing SSH repository.
func (r ApiRepositoryServiceValidateAccessRequest) SshPrivateKey(sshPrivateKey string) ApiRepositoryServiceValidateAccessRequest {
	r.sshPrivateKey = &sshPrivateKey
	return r
}
// Whether to skip certificate or host key validation.
func (r ApiRepositoryServiceValidateAccessRequest) Insecure(insecure bool) ApiRepositoryServiceValidateAccessRequest {
	r.insecure = &insecure
	return r
}
// TLS client cert data for accessing HTTPS repository.
func (r ApiRepositoryServiceValidateAccessRequest) TlsClientCertData(tlsClientCertData string) ApiRepositoryServiceValidateAccessRequest {
	r.tlsClientCertData = &tlsClientCertData
	return r
}
// TLS client cert key for accessing HTTPS repository.
func (r ApiRepositoryServiceValidateAccessRequest) TlsClientCertKey(tlsClientCertKey string) ApiRepositoryServiceValidateAccessRequest {
	r.tlsClientCertKey = &tlsClientCertKey
	return r
}
// The type of the repo.
func (r ApiRepositoryServiceValidateAccessRequest) Type_(type_ string) ApiRepositoryServiceValidateAccessRequest {
	r.type_ = &type_
	return r
}
// The name of the repo.
func (r ApiRepositoryServiceValidateAccessRequest) Name(name string) ApiRepositoryServiceValidateAccessRequest {
	r.name = &name
	return r
}
// Whether helm-oci support should be enabled for this repo.
func (r ApiRepositoryServiceValidateAccessRequest) EnableOci(enableOci bool) ApiRepositoryServiceValidateAccessRequest {
	r.enableOci = &enableOci
	return r
}
// Github App Private Key PEM data.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppPrivateKey(githubAppPrivateKey string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppPrivateKey = &githubAppPrivateKey
	return r
}
// Github App ID of the app used to access the repo.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppID(githubAppID string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppID = &githubAppID
	return r
}
// Github App Installation ID of the installed GitHub App.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppInstallationID(githubAppInstallationID string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppInstallationID = &githubAppInstallationID
	return r
}
// Github App Enterprise base url if empty will default to https://api.github.com.
func (r ApiRepositoryServiceValidateAccessRequest) GithubAppEnterpriseBaseUrl(githubAppEnterpriseBaseUrl string) ApiRepositoryServiceValidateAccessRequest {
	r.githubAppEnterpriseBaseUrl = &githubAppEnterpriseBaseUrl
	return r
}
// HTTP/HTTPS proxy to access the repository.
func (r ApiRepositoryServiceValidateAccessRequest) Proxy(proxy string) ApiRepositoryServiceValidateAccessRequest {
	r.proxy = &proxy
	return r
}
// Reference between project and repository that allow you automatically to be added as item inside SourceRepos project entity.
func (r ApiRepositoryServiceValidateAccessRequest) Project(project string) ApiRepositoryServiceValidateAccessRequest {
	r.project = &project
	return r
}
// Google Cloud Platform service account key.
func (r ApiRepositoryServiceValidateAccessRequest) GcpServiceAccountKey(gcpServiceAccountKey string) ApiRepositoryServiceValidateAccessRequest {
	r.gcpServiceAccountKey = &gcpServiceAccountKey
	return r
}
// Whether to force HTTP basic auth.
func (r ApiRepositoryServiceValidateAccessRequest) ForceHttpBasicAuth(forceHttpBasicAuth bool) ApiRepositoryServiceValidateAccessRequest {
	r.forceHttpBasicAuth = &forceHttpBasicAuth
	return r
}

func (r ApiRepositoryServiceValidateAccessRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.RepositoryServiceValidateAccessExecute(r)
}

/*
RepositoryServiceValidateAccess ValidateAccess validates access to a repository with given parameters

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param repo The URL to the repo
 @return ApiRepositoryServiceValidateAccessRequest
*/
func (a *RepositoryServiceApiService) RepositoryServiceValidateAccess(ctx _context.Context, repo string) ApiRepositoryServiceValidateAccessRequest {
	return ApiRepositoryServiceValidateAccessRequest{
		ApiService: a,
		ctx: ctx,
		repo: repo,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *RepositoryServiceApiService) RepositoryServiceValidateAccessExecute(r ApiRepositoryServiceValidateAccessRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RepositoryServiceApiService.RepositoryServiceValidateAccess")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/repositories/{repo}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", _neturl.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.username != nil {
		localVarQueryParams.Add("username", parameterToString(*r.username, ""))
	}
	if r.password != nil {
		localVarQueryParams.Add("password", parameterToString(*r.password, ""))
	}
	if r.sshPrivateKey != nil {
		localVarQueryParams.Add("sshPrivateKey", parameterToString(*r.sshPrivateKey, ""))
	}
	if r.insecure != nil {
		localVarQueryParams.Add("insecure", parameterToString(*r.insecure, ""))
	}
	if r.tlsClientCertData != nil {
		localVarQueryParams.Add("tlsClientCertData", parameterToString(*r.tlsClientCertData, ""))
	}
	if r.tlsClientCertKey != nil {
		localVarQueryParams.Add("tlsClientCertKey", parameterToString(*r.tlsClientCertKey, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.enableOci != nil {
		localVarQueryParams.Add("enableOci", parameterToString(*r.enableOci, ""))
	}
	if r.githubAppPrivateKey != nil {
		localVarQueryParams.Add("githubAppPrivateKey", parameterToString(*r.githubAppPrivateKey, ""))
	}
	if r.githubAppID != nil {
		localVarQueryParams.Add("githubAppID", parameterToString(*r.githubAppID, ""))
	}
	if r.githubAppInstallationID != nil {
		localVarQueryParams.Add("githubAppInstallationID", parameterToString(*r.githubAppInstallationID, ""))
	}
	if r.githubAppEnterpriseBaseUrl != nil {
		localVarQueryParams.Add("githubAppEnterpriseBaseUrl", parameterToString(*r.githubAppEnterpriseBaseUrl, ""))
	}
	if r.proxy != nil {
		localVarQueryParams.Add("proxy", parameterToString(*r.proxy, ""))
	}
	if r.project != nil {
		localVarQueryParams.Add("project", parameterToString(*r.project, ""))
	}
	if r.gcpServiceAccountKey != nil {
		localVarQueryParams.Add("gcpServiceAccountKey", parameterToString(*r.gcpServiceAccountKey, ""))
	}
	if r.forceHttpBasicAuth != nil {
		localVarQueryParams.Add("forceHttpBasicAuth", parameterToString(*r.forceHttpBasicAuth, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
