/*
Consolidate Services

Description of all APIs

API version: version not set
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapiclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// ApplicationServiceApiService ApplicationServiceApi service
type ApplicationServiceApiService service

type ApiApplicationServiceCreateRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	body *V1alpha1Application
	upsert *bool
	validate *bool
}

func (r ApiApplicationServiceCreateRequest) Body(body V1alpha1Application) ApiApplicationServiceCreateRequest {
	r.body = &body
	return r
}
func (r ApiApplicationServiceCreateRequest) Upsert(upsert bool) ApiApplicationServiceCreateRequest {
	r.upsert = &upsert
	return r
}
func (r ApiApplicationServiceCreateRequest) Validate(validate bool) ApiApplicationServiceCreateRequest {
	r.validate = &validate
	return r
}

func (r ApiApplicationServiceCreateRequest) Execute() (V1alpha1Application, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceCreateExecute(r)
}

/*
ApplicationServiceCreate Create creates an application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplicationServiceCreateRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceCreate(ctx _context.Context) ApiApplicationServiceCreateRequest {
	return ApiApplicationServiceCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceCreateExecute(r ApiApplicationServiceCreateRequest) (V1alpha1Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceCreate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.upsert != nil {
		localVarQueryParams.Add("upsert", parameterToString(*r.upsert, ""))
	}
	if r.validate != nil {
		localVarQueryParams.Add("validate", parameterToString(*r.validate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceDeleteRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	cascade *bool
	propagationPolicy *string
	appNamespace *string
}

func (r ApiApplicationServiceDeleteRequest) Cascade(cascade bool) ApiApplicationServiceDeleteRequest {
	r.cascade = &cascade
	return r
}
func (r ApiApplicationServiceDeleteRequest) PropagationPolicy(propagationPolicy string) ApiApplicationServiceDeleteRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}
func (r ApiApplicationServiceDeleteRequest) AppNamespace(appNamespace string) ApiApplicationServiceDeleteRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceDeleteRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceDeleteExecute(r)
}

/*
ApplicationServiceDelete Delete deletes an application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceDeleteRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceDelete(ctx _context.Context, name string) ApiApplicationServiceDeleteRequest {
	return ApiApplicationServiceDeleteRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceDeleteExecute(r ApiApplicationServiceDeleteRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.cascade != nil {
		localVarQueryParams.Add("cascade", parameterToString(*r.cascade, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceDeleteResourceRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	namespace *string
	resourceName *string
	version *string
	group *string
	kind *string
	force *bool
	orphan *bool
	appNamespace *string
}

func (r ApiApplicationServiceDeleteResourceRequest) Namespace(namespace string) ApiApplicationServiceDeleteResourceRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceDeleteResourceRequest) ResourceName(resourceName string) ApiApplicationServiceDeleteResourceRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServiceDeleteResourceRequest) Version(version string) ApiApplicationServiceDeleteResourceRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceDeleteResourceRequest) Group(group string) ApiApplicationServiceDeleteResourceRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceDeleteResourceRequest) Kind(kind string) ApiApplicationServiceDeleteResourceRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceDeleteResourceRequest) Force(force bool) ApiApplicationServiceDeleteResourceRequest {
	r.force = &force
	return r
}
func (r ApiApplicationServiceDeleteResourceRequest) Orphan(orphan bool) ApiApplicationServiceDeleteResourceRequest {
	r.orphan = &orphan
	return r
}
func (r ApiApplicationServiceDeleteResourceRequest) AppNamespace(appNamespace string) ApiApplicationServiceDeleteResourceRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceDeleteResourceRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceDeleteResourceExecute(r)
}

/*
ApplicationServiceDeleteResource DeleteResource deletes a single application resource

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceDeleteResourceRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceDeleteResource(ctx _context.Context, name string) ApiApplicationServiceDeleteResourceRequest {
	return ApiApplicationServiceDeleteResourceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceDeleteResourceExecute(r ApiApplicationServiceDeleteResourceRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceDeleteResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	if r.orphan != nil {
		localVarQueryParams.Add("orphan", parameterToString(*r.orphan, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	refresh *string
	projects *[]string
	resourceVersion *string
	selector *string
	repo *string
	appNamespace *string
	project *[]string
}

// forces application reconciliation if set to true.
func (r ApiApplicationServiceGetRequest) Refresh(refresh string) ApiApplicationServiceGetRequest {
	r.refresh = &refresh
	return r
}
// the project names to restrict returned list applications.
func (r ApiApplicationServiceGetRequest) Projects(projects []string) ApiApplicationServiceGetRequest {
	r.projects = &projects
	return r
}
// when specified with a watch call, shows changes that occur after that particular version of a resource.
func (r ApiApplicationServiceGetRequest) ResourceVersion(resourceVersion string) ApiApplicationServiceGetRequest {
	r.resourceVersion = &resourceVersion
	return r
}
// the selector to restrict returned list to applications only with matched labels.
func (r ApiApplicationServiceGetRequest) Selector(selector string) ApiApplicationServiceGetRequest {
	r.selector = &selector
	return r
}
// the repoURL to restrict returned list applications.
func (r ApiApplicationServiceGetRequest) Repo(repo string) ApiApplicationServiceGetRequest {
	r.repo = &repo
	return r
}
// the application&#39;s namespace.
func (r ApiApplicationServiceGetRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetRequest {
	r.appNamespace = &appNamespace
	return r
}
// the project names to restrict returned list applications (legacy name for backwards-compatibility).
func (r ApiApplicationServiceGetRequest) Project(project []string) ApiApplicationServiceGetRequest {
	r.project = &project
	return r
}

func (r ApiApplicationServiceGetRequest) Execute() (V1alpha1Application, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceGetExecute(r)
}

/*
ApplicationServiceGet Get returns an application by name

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name the application's name
 @return ApiApplicationServiceGetRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGet(ctx _context.Context, name string) ApiApplicationServiceGetRequest {
	return ApiApplicationServiceGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceGetExecute(r ApiApplicationServiceGetRequest) (V1alpha1Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	if r.projects != nil {
		t := *r.projects
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("projects", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("projects", parameterToString(t, "multi"))
		}
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.selector != nil {
		localVarQueryParams.Add("selector", parameterToString(*r.selector, ""))
	}
	if r.repo != nil {
		localVarQueryParams.Add("repo", parameterToString(*r.repo, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	if r.project != nil {
		t := *r.project
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("project", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("project", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetApplicationSyncWindowsRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	appNamespace *string
}

func (r ApiApplicationServiceGetApplicationSyncWindowsRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetApplicationSyncWindowsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceGetApplicationSyncWindowsRequest) Execute() (ApplicationApplicationSyncWindowsResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceGetApplicationSyncWindowsExecute(r)
}

/*
ApplicationServiceGetApplicationSyncWindows Get returns sync windows of the application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceGetApplicationSyncWindowsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetApplicationSyncWindows(ctx _context.Context, name string) ApiApplicationServiceGetApplicationSyncWindowsRequest {
	return ApiApplicationServiceGetApplicationSyncWindowsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ApplicationApplicationSyncWindowsResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetApplicationSyncWindowsExecute(r ApiApplicationServiceGetApplicationSyncWindowsRequest) (ApplicationApplicationSyncWindowsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ApplicationApplicationSyncWindowsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetApplicationSyncWindows")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/syncwindows"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetManifestsRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	revision *string
	appNamespace *string
}

func (r ApiApplicationServiceGetManifestsRequest) Revision(revision string) ApiApplicationServiceGetManifestsRequest {
	r.revision = &revision
	return r
}
func (r ApiApplicationServiceGetManifestsRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetManifestsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceGetManifestsRequest) Execute() (RepositoryManifestResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceGetManifestsExecute(r)
}

/*
ApplicationServiceGetManifests GetManifests returns application manifests

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceGetManifestsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetManifests(ctx _context.Context, name string) ApiApplicationServiceGetManifestsRequest {
	return ApiApplicationServiceGetManifestsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return RepositoryManifestResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetManifestsExecute(r ApiApplicationServiceGetManifestsRequest) (RepositoryManifestResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  RepositoryManifestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetManifests")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/manifests"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.revision != nil {
		localVarQueryParams.Add("revision", parameterToString(*r.revision, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetManifestsWithFilesRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	body *ApplicationApplicationManifestQueryWithFilesWrapper
}

//  (streaming inputs)
func (r ApiApplicationServiceGetManifestsWithFilesRequest) Body(body ApplicationApplicationManifestQueryWithFilesWrapper) ApiApplicationServiceGetManifestsWithFilesRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceGetManifestsWithFilesRequest) Execute() (RepositoryManifestResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceGetManifestsWithFilesExecute(r)
}

/*
ApplicationServiceGetManifestsWithFiles GetManifestsWithFiles returns application manifests using provided files to generate them

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplicationServiceGetManifestsWithFilesRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetManifestsWithFiles(ctx _context.Context) ApiApplicationServiceGetManifestsWithFilesRequest {
	return ApiApplicationServiceGetManifestsWithFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RepositoryManifestResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetManifestsWithFilesExecute(r ApiApplicationServiceGetManifestsWithFilesRequest) (RepositoryManifestResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  RepositoryManifestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetManifestsWithFiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/manifestsWithFiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceGetResourceRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	namespace *string
	resourceName *string
	version *string
	group *string
	kind *string
	appNamespace *string
}

func (r ApiApplicationServiceGetResourceRequest) Namespace(namespace string) ApiApplicationServiceGetResourceRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceGetResourceRequest) ResourceName(resourceName string) ApiApplicationServiceGetResourceRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServiceGetResourceRequest) Version(version string) ApiApplicationServiceGetResourceRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceGetResourceRequest) Group(group string) ApiApplicationServiceGetResourceRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceGetResourceRequest) Kind(kind string) ApiApplicationServiceGetResourceRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceGetResourceRequest) AppNamespace(appNamespace string) ApiApplicationServiceGetResourceRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceGetResourceRequest) Execute() (ApplicationApplicationResourceResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceGetResourceExecute(r)
}

/*
ApplicationServiceGetResource GetResource returns single application resource

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceGetResourceRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceGetResource(ctx _context.Context, name string) ApiApplicationServiceGetResourceRequest {
	return ApiApplicationServiceGetResourceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ApplicationApplicationResourceResponse
func (a *ApplicationServiceApiService) ApplicationServiceGetResourceExecute(r ApiApplicationServiceGetResourceRequest) (ApplicationApplicationResourceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ApplicationApplicationResourceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceGetResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name *string
	refresh *string
	projects *[]string
	resourceVersion *string
	selector *string
	repo *string
	appNamespace *string
	project *[]string
}

// the application&#39;s name.
func (r ApiApplicationServiceListRequest) Name(name string) ApiApplicationServiceListRequest {
	r.name = &name
	return r
}
// forces application reconciliation if set to true.
func (r ApiApplicationServiceListRequest) Refresh(refresh string) ApiApplicationServiceListRequest {
	r.refresh = &refresh
	return r
}
// the project names to restrict returned list applications.
func (r ApiApplicationServiceListRequest) Projects(projects []string) ApiApplicationServiceListRequest {
	r.projects = &projects
	return r
}
// when specified with a watch call, shows changes that occur after that particular version of a resource.
func (r ApiApplicationServiceListRequest) ResourceVersion(resourceVersion string) ApiApplicationServiceListRequest {
	r.resourceVersion = &resourceVersion
	return r
}
// the selector to restrict returned list to applications only with matched labels.
func (r ApiApplicationServiceListRequest) Selector(selector string) ApiApplicationServiceListRequest {
	r.selector = &selector
	return r
}
// the repoURL to restrict returned list applications.
func (r ApiApplicationServiceListRequest) Repo(repo string) ApiApplicationServiceListRequest {
	r.repo = &repo
	return r
}
// the application&#39;s namespace.
func (r ApiApplicationServiceListRequest) AppNamespace(appNamespace string) ApiApplicationServiceListRequest {
	r.appNamespace = &appNamespace
	return r
}
// the project names to restrict returned list applications (legacy name for backwards-compatibility).
func (r ApiApplicationServiceListRequest) Project(project []string) ApiApplicationServiceListRequest {
	r.project = &project
	return r
}

func (r ApiApplicationServiceListRequest) Execute() (V1alpha1ApplicationList, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceListExecute(r)
}

/*
ApplicationServiceList List returns list of applications

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplicationServiceListRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceList(ctx _context.Context) ApiApplicationServiceListRequest {
	return ApiApplicationServiceListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1alpha1ApplicationList
func (a *ApplicationServiceApiService) ApplicationServiceListExecute(r ApiApplicationServiceListRequest) (V1alpha1ApplicationList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1ApplicationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	if r.projects != nil {
		t := *r.projects
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("projects", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("projects", parameterToString(t, "multi"))
		}
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.selector != nil {
		localVarQueryParams.Add("selector", parameterToString(*r.selector, ""))
	}
	if r.repo != nil {
		localVarQueryParams.Add("repo", parameterToString(*r.repo, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	if r.project != nil {
		t := *r.project
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("project", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("project", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListLinksRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	namespace *string
}

func (r ApiApplicationServiceListLinksRequest) Namespace(namespace string) ApiApplicationServiceListLinksRequest {
	r.namespace = &namespace
	return r
}

func (r ApiApplicationServiceListLinksRequest) Execute() (ApplicationLinksResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceListLinksExecute(r)
}

/*
ApplicationServiceListLinks ListLinks returns the list of all application deep links

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceListLinksRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceListLinks(ctx _context.Context, name string) ApiApplicationServiceListLinksRequest {
	return ApiApplicationServiceListLinksRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ApplicationLinksResponse
func (a *ApplicationServiceApiService) ApplicationServiceListLinksExecute(r ApiApplicationServiceListLinksRequest) (ApplicationLinksResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ApplicationLinksResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceListLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/links"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListResourceActionsRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	namespace *string
	resourceName *string
	version *string
	group *string
	kind *string
	appNamespace *string
}

func (r ApiApplicationServiceListResourceActionsRequest) Namespace(namespace string) ApiApplicationServiceListResourceActionsRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceListResourceActionsRequest) ResourceName(resourceName string) ApiApplicationServiceListResourceActionsRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServiceListResourceActionsRequest) Version(version string) ApiApplicationServiceListResourceActionsRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceListResourceActionsRequest) Group(group string) ApiApplicationServiceListResourceActionsRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceListResourceActionsRequest) Kind(kind string) ApiApplicationServiceListResourceActionsRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceListResourceActionsRequest) AppNamespace(appNamespace string) ApiApplicationServiceListResourceActionsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceListResourceActionsRequest) Execute() (ApplicationResourceActionsListResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceListResourceActionsExecute(r)
}

/*
ApplicationServiceListResourceActions ListResourceActions returns list of resource actions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceListResourceActionsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceListResourceActions(ctx _context.Context, name string) ApiApplicationServiceListResourceActionsRequest {
	return ApiApplicationServiceListResourceActionsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ApplicationResourceActionsListResponse
func (a *ApplicationServiceApiService) ApplicationServiceListResourceActionsExecute(r ApiApplicationServiceListResourceActionsRequest) (ApplicationResourceActionsListResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ApplicationResourceActionsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceListResourceActions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListResourceEventsRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	resourceNamespace *string
	resourceName *string
	resourceUID *string
	appNamespace *string
}

func (r ApiApplicationServiceListResourceEventsRequest) ResourceNamespace(resourceNamespace string) ApiApplicationServiceListResourceEventsRequest {
	r.resourceNamespace = &resourceNamespace
	return r
}
func (r ApiApplicationServiceListResourceEventsRequest) ResourceName(resourceName string) ApiApplicationServiceListResourceEventsRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServiceListResourceEventsRequest) ResourceUID(resourceUID string) ApiApplicationServiceListResourceEventsRequest {
	r.resourceUID = &resourceUID
	return r
}
func (r ApiApplicationServiceListResourceEventsRequest) AppNamespace(appNamespace string) ApiApplicationServiceListResourceEventsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceListResourceEventsRequest) Execute() (V1EventList, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceListResourceEventsExecute(r)
}

/*
ApplicationServiceListResourceEvents ListResourceEvents returns a list of event resources

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceListResourceEventsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceListResourceEvents(ctx _context.Context, name string) ApiApplicationServiceListResourceEventsRequest {
	return ApiApplicationServiceListResourceEventsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1EventList
func (a *ApplicationServiceApiService) ApplicationServiceListResourceEventsExecute(r ApiApplicationServiceListResourceEventsRequest) (V1EventList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1EventList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceListResourceEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.resourceNamespace != nil {
		localVarQueryParams.Add("resourceNamespace", parameterToString(*r.resourceNamespace, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.resourceUID != nil {
		localVarQueryParams.Add("resourceUID", parameterToString(*r.resourceUID, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceListResourceLinksRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	namespace *string
	resourceName *string
	version *string
	group *string
	kind *string
	appNamespace *string
}

func (r ApiApplicationServiceListResourceLinksRequest) Namespace(namespace string) ApiApplicationServiceListResourceLinksRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceListResourceLinksRequest) ResourceName(resourceName string) ApiApplicationServiceListResourceLinksRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServiceListResourceLinksRequest) Version(version string) ApiApplicationServiceListResourceLinksRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceListResourceLinksRequest) Group(group string) ApiApplicationServiceListResourceLinksRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceListResourceLinksRequest) Kind(kind string) ApiApplicationServiceListResourceLinksRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceListResourceLinksRequest) AppNamespace(appNamespace string) ApiApplicationServiceListResourceLinksRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceListResourceLinksRequest) Execute() (ApplicationLinksResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceListResourceLinksExecute(r)
}

/*
ApplicationServiceListResourceLinks ListResourceLinks returns the list of all resource deep links

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceListResourceLinksRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceListResourceLinks(ctx _context.Context, name string) ApiApplicationServiceListResourceLinksRequest {
	return ApiApplicationServiceListResourceLinksRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ApplicationLinksResponse
func (a *ApplicationServiceApiService) ApplicationServiceListResourceLinksExecute(r ApiApplicationServiceListResourceLinksRequest) (ApplicationLinksResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ApplicationLinksResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceListResourceLinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource/links"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceManagedResourcesRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	applicationName string
	namespace *string
	name *string
	version *string
	group *string
	kind *string
	appNamespace *string
}

func (r ApiApplicationServiceManagedResourcesRequest) Namespace(namespace string) ApiApplicationServiceManagedResourcesRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceManagedResourcesRequest) Name(name string) ApiApplicationServiceManagedResourcesRequest {
	r.name = &name
	return r
}
func (r ApiApplicationServiceManagedResourcesRequest) Version(version string) ApiApplicationServiceManagedResourcesRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceManagedResourcesRequest) Group(group string) ApiApplicationServiceManagedResourcesRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceManagedResourcesRequest) Kind(kind string) ApiApplicationServiceManagedResourcesRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceManagedResourcesRequest) AppNamespace(appNamespace string) ApiApplicationServiceManagedResourcesRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceManagedResourcesRequest) Execute() (ApplicationManagedResourcesResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceManagedResourcesExecute(r)
}

/*
ApplicationServiceManagedResources ManagedResources returns list of managed resources

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationName
 @return ApiApplicationServiceManagedResourcesRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceManagedResources(ctx _context.Context, applicationName string) ApiApplicationServiceManagedResourcesRequest {
	return ApiApplicationServiceManagedResourcesRequest{
		ApiService: a,
		ctx: ctx,
		applicationName: applicationName,
	}
}

// Execute executes the request
//  @return ApplicationManagedResourcesResponse
func (a *ApplicationServiceApiService) ApplicationServiceManagedResourcesExecute(r ApiApplicationServiceManagedResourcesRequest) (ApplicationManagedResourcesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ApplicationManagedResourcesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceManagedResources")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{applicationName}/managed-resources"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationName"+"}", _neturl.PathEscape(parameterToString(r.applicationName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePatchRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	body *ApplicationApplicationPatchRequest
}

func (r ApiApplicationServicePatchRequest) Body(body ApplicationApplicationPatchRequest) ApiApplicationServicePatchRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServicePatchRequest) Execute() (V1alpha1Application, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServicePatchExecute(r)
}

/*
ApplicationServicePatch Patch patch an application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServicePatchRequest
*/
func (a *ApplicationServiceApiService) ApplicationServicePatch(ctx _context.Context, name string) ApiApplicationServicePatchRequest {
	return ApiApplicationServicePatchRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServicePatchExecute(r ApiApplicationServicePatchRequest) (V1alpha1Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePatchResourceRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	body *string
	namespace *string
	resourceName *string
	version *string
	group *string
	kind *string
	patchType *string
	appNamespace *string
}

func (r ApiApplicationServicePatchResourceRequest) Body(body string) ApiApplicationServicePatchResourceRequest {
	r.body = &body
	return r
}
func (r ApiApplicationServicePatchResourceRequest) Namespace(namespace string) ApiApplicationServicePatchResourceRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServicePatchResourceRequest) ResourceName(resourceName string) ApiApplicationServicePatchResourceRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServicePatchResourceRequest) Version(version string) ApiApplicationServicePatchResourceRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServicePatchResourceRequest) Group(group string) ApiApplicationServicePatchResourceRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServicePatchResourceRequest) Kind(kind string) ApiApplicationServicePatchResourceRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServicePatchResourceRequest) PatchType(patchType string) ApiApplicationServicePatchResourceRequest {
	r.patchType = &patchType
	return r
}
func (r ApiApplicationServicePatchResourceRequest) AppNamespace(appNamespace string) ApiApplicationServicePatchResourceRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServicePatchResourceRequest) Execute() (ApplicationApplicationResourceResponse, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServicePatchResourceExecute(r)
}

/*
ApplicationServicePatchResource PatchResource patch single application resource

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServicePatchResourceRequest
*/
func (a *ApplicationServiceApiService) ApplicationServicePatchResource(ctx _context.Context, name string) ApiApplicationServicePatchResourceRequest {
	return ApiApplicationServicePatchResourceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ApplicationApplicationResourceResponse
func (a *ApplicationServiceApiService) ApplicationServicePatchResourceExecute(r ApiApplicationServicePatchResourceRequest) (ApplicationApplicationResourceResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  ApplicationApplicationResourceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePatchResource")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.patchType != nil {
		localVarQueryParams.Add("patchType", parameterToString(*r.patchType, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePodLogsRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	podName string
	namespace *string
	container *string
	sinceSeconds *string
	sinceTimeSeconds *string
	sinceTimeNanos *int32
	tailLines *string
	follow *bool
	untilTime *string
	filter *string
	kind *string
	group *string
	resourceName *string
	previous *bool
	appNamespace *string
}

func (r ApiApplicationServicePodLogsRequest) Namespace(namespace string) ApiApplicationServicePodLogsRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServicePodLogsRequest) Container(container string) ApiApplicationServicePodLogsRequest {
	r.container = &container
	return r
}
func (r ApiApplicationServicePodLogsRequest) SinceSeconds(sinceSeconds string) ApiApplicationServicePodLogsRequest {
	r.sinceSeconds = &sinceSeconds
	return r
}
// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
func (r ApiApplicationServicePodLogsRequest) SinceTimeSeconds(sinceTimeSeconds string) ApiApplicationServicePodLogsRequest {
	r.sinceTimeSeconds = &sinceTimeSeconds
	return r
}
// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
func (r ApiApplicationServicePodLogsRequest) SinceTimeNanos(sinceTimeNanos int32) ApiApplicationServicePodLogsRequest {
	r.sinceTimeNanos = &sinceTimeNanos
	return r
}
func (r ApiApplicationServicePodLogsRequest) TailLines(tailLines string) ApiApplicationServicePodLogsRequest {
	r.tailLines = &tailLines
	return r
}
func (r ApiApplicationServicePodLogsRequest) Follow(follow bool) ApiApplicationServicePodLogsRequest {
	r.follow = &follow
	return r
}
func (r ApiApplicationServicePodLogsRequest) UntilTime(untilTime string) ApiApplicationServicePodLogsRequest {
	r.untilTime = &untilTime
	return r
}
func (r ApiApplicationServicePodLogsRequest) Filter(filter string) ApiApplicationServicePodLogsRequest {
	r.filter = &filter
	return r
}
func (r ApiApplicationServicePodLogsRequest) Kind(kind string) ApiApplicationServicePodLogsRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServicePodLogsRequest) Group(group string) ApiApplicationServicePodLogsRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServicePodLogsRequest) ResourceName(resourceName string) ApiApplicationServicePodLogsRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServicePodLogsRequest) Previous(previous bool) ApiApplicationServicePodLogsRequest {
	r.previous = &previous
	return r
}
func (r ApiApplicationServicePodLogsRequest) AppNamespace(appNamespace string) ApiApplicationServicePodLogsRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServicePodLogsRequest) Execute() (StreamResultOfApplicationLogEntry, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServicePodLogsExecute(r)
}

/*
ApplicationServicePodLogs PodLogs returns stream of log entries for the specified pod. Pod

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param podName
 @return ApiApplicationServicePodLogsRequest
*/
func (a *ApplicationServiceApiService) ApplicationServicePodLogs(ctx _context.Context, name string, podName string) ApiApplicationServicePodLogsRequest {
	return ApiApplicationServicePodLogsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		podName: podName,
	}
}

// Execute executes the request
//  @return StreamResultOfApplicationLogEntry
func (a *ApplicationServiceApiService) ApplicationServicePodLogsExecute(r ApiApplicationServicePodLogsRequest) (StreamResultOfApplicationLogEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  StreamResultOfApplicationLogEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePodLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/pods/{podName}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"podName"+"}", _neturl.PathEscape(parameterToString(r.podName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.container != nil {
		localVarQueryParams.Add("container", parameterToString(*r.container, ""))
	}
	if r.sinceSeconds != nil {
		localVarQueryParams.Add("sinceSeconds", parameterToString(*r.sinceSeconds, ""))
	}
	if r.sinceTimeSeconds != nil {
		localVarQueryParams.Add("sinceTime.seconds", parameterToString(*r.sinceTimeSeconds, ""))
	}
	if r.sinceTimeNanos != nil {
		localVarQueryParams.Add("sinceTime.nanos", parameterToString(*r.sinceTimeNanos, ""))
	}
	if r.tailLines != nil {
		localVarQueryParams.Add("tailLines", parameterToString(*r.tailLines, ""))
	}
	if r.follow != nil {
		localVarQueryParams.Add("follow", parameterToString(*r.follow, ""))
	}
	if r.untilTime != nil {
		localVarQueryParams.Add("untilTime", parameterToString(*r.untilTime, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.previous != nil {
		localVarQueryParams.Add("previous", parameterToString(*r.previous, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServicePodLogs2Request struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	namespace *string
	podName *string
	container *string
	sinceSeconds *string
	sinceTimeSeconds *string
	sinceTimeNanos *int32
	tailLines *string
	follow *bool
	untilTime *string
	filter *string
	kind *string
	group *string
	resourceName *string
	previous *bool
	appNamespace *string
}

func (r ApiApplicationServicePodLogs2Request) Namespace(namespace string) ApiApplicationServicePodLogs2Request {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServicePodLogs2Request) PodName(podName string) ApiApplicationServicePodLogs2Request {
	r.podName = &podName
	return r
}
func (r ApiApplicationServicePodLogs2Request) Container(container string) ApiApplicationServicePodLogs2Request {
	r.container = &container
	return r
}
func (r ApiApplicationServicePodLogs2Request) SinceSeconds(sinceSeconds string) ApiApplicationServicePodLogs2Request {
	r.sinceSeconds = &sinceSeconds
	return r
}
// Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
func (r ApiApplicationServicePodLogs2Request) SinceTimeSeconds(sinceTimeSeconds string) ApiApplicationServicePodLogs2Request {
	r.sinceTimeSeconds = &sinceTimeSeconds
	return r
}
// Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
func (r ApiApplicationServicePodLogs2Request) SinceTimeNanos(sinceTimeNanos int32) ApiApplicationServicePodLogs2Request {
	r.sinceTimeNanos = &sinceTimeNanos
	return r
}
func (r ApiApplicationServicePodLogs2Request) TailLines(tailLines string) ApiApplicationServicePodLogs2Request {
	r.tailLines = &tailLines
	return r
}
func (r ApiApplicationServicePodLogs2Request) Follow(follow bool) ApiApplicationServicePodLogs2Request {
	r.follow = &follow
	return r
}
func (r ApiApplicationServicePodLogs2Request) UntilTime(untilTime string) ApiApplicationServicePodLogs2Request {
	r.untilTime = &untilTime
	return r
}
func (r ApiApplicationServicePodLogs2Request) Filter(filter string) ApiApplicationServicePodLogs2Request {
	r.filter = &filter
	return r
}
func (r ApiApplicationServicePodLogs2Request) Kind(kind string) ApiApplicationServicePodLogs2Request {
	r.kind = &kind
	return r
}
func (r ApiApplicationServicePodLogs2Request) Group(group string) ApiApplicationServicePodLogs2Request {
	r.group = &group
	return r
}
func (r ApiApplicationServicePodLogs2Request) ResourceName(resourceName string) ApiApplicationServicePodLogs2Request {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServicePodLogs2Request) Previous(previous bool) ApiApplicationServicePodLogs2Request {
	r.previous = &previous
	return r
}
func (r ApiApplicationServicePodLogs2Request) AppNamespace(appNamespace string) ApiApplicationServicePodLogs2Request {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServicePodLogs2Request) Execute() (StreamResultOfApplicationLogEntry, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServicePodLogs2Execute(r)
}

/*
ApplicationServicePodLogs2 PodLogs returns stream of log entries for the specified pod. Pod

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServicePodLogs2Request
*/
func (a *ApplicationServiceApiService) ApplicationServicePodLogs2(ctx _context.Context, name string) ApiApplicationServicePodLogs2Request {
	return ApiApplicationServicePodLogs2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return StreamResultOfApplicationLogEntry
func (a *ApplicationServiceApiService) ApplicationServicePodLogs2Execute(r ApiApplicationServicePodLogs2Request) (StreamResultOfApplicationLogEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  StreamResultOfApplicationLogEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServicePodLogs2")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.podName != nil {
		localVarQueryParams.Add("podName", parameterToString(*r.podName, ""))
	}
	if r.container != nil {
		localVarQueryParams.Add("container", parameterToString(*r.container, ""))
	}
	if r.sinceSeconds != nil {
		localVarQueryParams.Add("sinceSeconds", parameterToString(*r.sinceSeconds, ""))
	}
	if r.sinceTimeSeconds != nil {
		localVarQueryParams.Add("sinceTime.seconds", parameterToString(*r.sinceTimeSeconds, ""))
	}
	if r.sinceTimeNanos != nil {
		localVarQueryParams.Add("sinceTime.nanos", parameterToString(*r.sinceTimeNanos, ""))
	}
	if r.tailLines != nil {
		localVarQueryParams.Add("tailLines", parameterToString(*r.tailLines, ""))
	}
	if r.follow != nil {
		localVarQueryParams.Add("follow", parameterToString(*r.follow, ""))
	}
	if r.untilTime != nil {
		localVarQueryParams.Add("untilTime", parameterToString(*r.untilTime, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.previous != nil {
		localVarQueryParams.Add("previous", parameterToString(*r.previous, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceResourceTreeRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	applicationName string
	namespace *string
	name *string
	version *string
	group *string
	kind *string
	appNamespace *string
}

func (r ApiApplicationServiceResourceTreeRequest) Namespace(namespace string) ApiApplicationServiceResourceTreeRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceResourceTreeRequest) Name(name string) ApiApplicationServiceResourceTreeRequest {
	r.name = &name
	return r
}
func (r ApiApplicationServiceResourceTreeRequest) Version(version string) ApiApplicationServiceResourceTreeRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceResourceTreeRequest) Group(group string) ApiApplicationServiceResourceTreeRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceResourceTreeRequest) Kind(kind string) ApiApplicationServiceResourceTreeRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceResourceTreeRequest) AppNamespace(appNamespace string) ApiApplicationServiceResourceTreeRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceResourceTreeRequest) Execute() (V1alpha1ApplicationTree, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceResourceTreeExecute(r)
}

/*
ApplicationServiceResourceTree ResourceTree returns resource tree

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationName
 @return ApiApplicationServiceResourceTreeRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceResourceTree(ctx _context.Context, applicationName string) ApiApplicationServiceResourceTreeRequest {
	return ApiApplicationServiceResourceTreeRequest{
		ApiService: a,
		ctx: ctx,
		applicationName: applicationName,
	}
}

// Execute executes the request
//  @return V1alpha1ApplicationTree
func (a *ApplicationServiceApiService) ApplicationServiceResourceTreeExecute(r ApiApplicationServiceResourceTreeRequest) (V1alpha1ApplicationTree, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1ApplicationTree
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceResourceTree")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{applicationName}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationName"+"}", _neturl.PathEscape(parameterToString(r.applicationName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceRevisionMetadataRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	revision string
	appNamespace *string
}

// the application&#39;s namespace.
func (r ApiApplicationServiceRevisionMetadataRequest) AppNamespace(appNamespace string) ApiApplicationServiceRevisionMetadataRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceRevisionMetadataRequest) Execute() (V1alpha1RevisionMetadata, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceRevisionMetadataExecute(r)
}

/*
ApplicationServiceRevisionMetadata Get the meta-data (author, date, tags, message) for a specific revision of the application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name the application's name
 @param revision the revision of the app
 @return ApiApplicationServiceRevisionMetadataRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceRevisionMetadata(ctx _context.Context, name string, revision string) ApiApplicationServiceRevisionMetadataRequest {
	return ApiApplicationServiceRevisionMetadataRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		revision: revision,
	}
}

// Execute executes the request
//  @return V1alpha1RevisionMetadata
func (a *ApplicationServiceApiService) ApplicationServiceRevisionMetadataExecute(r ApiApplicationServiceRevisionMetadataRequest) (V1alpha1RevisionMetadata, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1RevisionMetadata
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceRevisionMetadata")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/revisions/{revision}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revision"+"}", _neturl.PathEscape(parameterToString(r.revision, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceRollbackRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	body *ApplicationApplicationRollbackRequest
}

func (r ApiApplicationServiceRollbackRequest) Body(body ApplicationApplicationRollbackRequest) ApiApplicationServiceRollbackRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceRollbackRequest) Execute() (V1alpha1Application, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceRollbackExecute(r)
}

/*
ApplicationServiceRollback Rollback syncs an application to its target state

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceRollbackRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceRollback(ctx _context.Context, name string) ApiApplicationServiceRollbackRequest {
	return ApiApplicationServiceRollbackRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceRollbackExecute(r ApiApplicationServiceRollbackRequest) (V1alpha1Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceRollback")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceRunResourceActionRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	body *string
	namespace *string
	resourceName *string
	version *string
	group *string
	kind *string
	appNamespace *string
}

func (r ApiApplicationServiceRunResourceActionRequest) Body(body string) ApiApplicationServiceRunResourceActionRequest {
	r.body = &body
	return r
}
func (r ApiApplicationServiceRunResourceActionRequest) Namespace(namespace string) ApiApplicationServiceRunResourceActionRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceRunResourceActionRequest) ResourceName(resourceName string) ApiApplicationServiceRunResourceActionRequest {
	r.resourceName = &resourceName
	return r
}
func (r ApiApplicationServiceRunResourceActionRequest) Version(version string) ApiApplicationServiceRunResourceActionRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceRunResourceActionRequest) Group(group string) ApiApplicationServiceRunResourceActionRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceRunResourceActionRequest) Kind(kind string) ApiApplicationServiceRunResourceActionRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceRunResourceActionRequest) AppNamespace(appNamespace string) ApiApplicationServiceRunResourceActionRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceRunResourceActionRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceRunResourceActionExecute(r)
}

/*
ApplicationServiceRunResourceAction RunResourceAction run resource action

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceRunResourceActionRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceRunResourceAction(ctx _context.Context, name string) ApiApplicationServiceRunResourceActionRequest {
	return ApiApplicationServiceRunResourceActionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceRunResourceActionExecute(r ApiApplicationServiceRunResourceActionRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceRunResourceAction")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/resource/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.resourceName != nil {
		localVarQueryParams.Add("resourceName", parameterToString(*r.resourceName, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceSyncRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	body *ApplicationApplicationSyncRequest
}

func (r ApiApplicationServiceSyncRequest) Body(body ApplicationApplicationSyncRequest) ApiApplicationServiceSyncRequest {
	r.body = &body
	return r
}

func (r ApiApplicationServiceSyncRequest) Execute() (V1alpha1Application, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceSyncExecute(r)
}

/*
ApplicationServiceSync Sync syncs an application to its target state

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceSyncRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceSync(ctx _context.Context, name string) ApiApplicationServiceSyncRequest {
	return ApiApplicationServiceSyncRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceSyncExecute(r ApiApplicationServiceSyncRequest) (V1alpha1Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceSync")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceTerminateOperationRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	appNamespace *string
}

func (r ApiApplicationServiceTerminateOperationRequest) AppNamespace(appNamespace string) ApiApplicationServiceTerminateOperationRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceTerminateOperationRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceTerminateOperationExecute(r)
}

/*
ApplicationServiceTerminateOperation TerminateOperation terminates the currently running operation

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceTerminateOperationRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceTerminateOperation(ctx _context.Context, name string) ApiApplicationServiceTerminateOperationRequest {
	return ApiApplicationServiceTerminateOperationRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ApplicationServiceApiService) ApplicationServiceTerminateOperationExecute(r ApiApplicationServiceTerminateOperationRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceTerminateOperation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/operation"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceUpdateRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	applicationMetadataName string
	body *V1alpha1Application
	validate *bool
}

func (r ApiApplicationServiceUpdateRequest) Body(body V1alpha1Application) ApiApplicationServiceUpdateRequest {
	r.body = &body
	return r
}
func (r ApiApplicationServiceUpdateRequest) Validate(validate bool) ApiApplicationServiceUpdateRequest {
	r.validate = &validate
	return r
}

func (r ApiApplicationServiceUpdateRequest) Execute() (V1alpha1Application, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceUpdateExecute(r)
}

/*
ApplicationServiceUpdate Update updates an application

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationMetadataName Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names +optional
 @return ApiApplicationServiceUpdateRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceUpdate(ctx _context.Context, applicationMetadataName string) ApiApplicationServiceUpdateRequest {
	return ApiApplicationServiceUpdateRequest{
		ApiService: a,
		ctx: ctx,
		applicationMetadataName: applicationMetadataName,
	}
}

// Execute executes the request
//  @return V1alpha1Application
func (a *ApplicationServiceApiService) ApplicationServiceUpdateExecute(r ApiApplicationServiceUpdateRequest) (V1alpha1Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1Application
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceUpdate")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{application.metadata.name}"
	localVarPath = strings.Replace(localVarPath, "{"+"application.metadata.name"+"}", _neturl.PathEscape(parameterToString(r.applicationMetadataName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.validate != nil {
		localVarQueryParams.Add("validate", parameterToString(*r.validate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceUpdateSpecRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name string
	body *V1alpha1ApplicationSpec
	validate *bool
	appNamespace *string
}

func (r ApiApplicationServiceUpdateSpecRequest) Body(body V1alpha1ApplicationSpec) ApiApplicationServiceUpdateSpecRequest {
	r.body = &body
	return r
}
func (r ApiApplicationServiceUpdateSpecRequest) Validate(validate bool) ApiApplicationServiceUpdateSpecRequest {
	r.validate = &validate
	return r
}
func (r ApiApplicationServiceUpdateSpecRequest) AppNamespace(appNamespace string) ApiApplicationServiceUpdateSpecRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceUpdateSpecRequest) Execute() (V1alpha1ApplicationSpec, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceUpdateSpecExecute(r)
}

/*
ApplicationServiceUpdateSpec UpdateSpec updates an application spec

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @return ApiApplicationServiceUpdateSpecRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceUpdateSpec(ctx _context.Context, name string) ApiApplicationServiceUpdateSpecRequest {
	return ApiApplicationServiceUpdateSpecRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1alpha1ApplicationSpec
func (a *ApplicationServiceApiService) ApplicationServiceUpdateSpecExecute(r ApiApplicationServiceUpdateSpecRequest) (V1alpha1ApplicationSpec, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  V1alpha1ApplicationSpec
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceUpdateSpec")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/applications/{name}/spec"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.validate != nil {
		localVarQueryParams.Add("validate", parameterToString(*r.validate, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceWatchRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	name *string
	refresh *string
	projects *[]string
	resourceVersion *string
	selector *string
	repo *string
	appNamespace *string
	project *[]string
}

// the application&#39;s name.
func (r ApiApplicationServiceWatchRequest) Name(name string) ApiApplicationServiceWatchRequest {
	r.name = &name
	return r
}
// forces application reconciliation if set to true.
func (r ApiApplicationServiceWatchRequest) Refresh(refresh string) ApiApplicationServiceWatchRequest {
	r.refresh = &refresh
	return r
}
// the project names to restrict returned list applications.
func (r ApiApplicationServiceWatchRequest) Projects(projects []string) ApiApplicationServiceWatchRequest {
	r.projects = &projects
	return r
}
// when specified with a watch call, shows changes that occur after that particular version of a resource.
func (r ApiApplicationServiceWatchRequest) ResourceVersion(resourceVersion string) ApiApplicationServiceWatchRequest {
	r.resourceVersion = &resourceVersion
	return r
}
// the selector to restrict returned list to applications only with matched labels.
func (r ApiApplicationServiceWatchRequest) Selector(selector string) ApiApplicationServiceWatchRequest {
	r.selector = &selector
	return r
}
// the repoURL to restrict returned list applications.
func (r ApiApplicationServiceWatchRequest) Repo(repo string) ApiApplicationServiceWatchRequest {
	r.repo = &repo
	return r
}
// the application&#39;s namespace.
func (r ApiApplicationServiceWatchRequest) AppNamespace(appNamespace string) ApiApplicationServiceWatchRequest {
	r.appNamespace = &appNamespace
	return r
}
// the project names to restrict returned list applications (legacy name for backwards-compatibility).
func (r ApiApplicationServiceWatchRequest) Project(project []string) ApiApplicationServiceWatchRequest {
	r.project = &project
	return r
}

func (r ApiApplicationServiceWatchRequest) Execute() (StreamResultOfV1alpha1ApplicationWatchEvent, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceWatchExecute(r)
}

/*
ApplicationServiceWatch Watch returns stream of application change events

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApplicationServiceWatchRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceWatch(ctx _context.Context) ApiApplicationServiceWatchRequest {
	return ApiApplicationServiceWatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StreamResultOfV1alpha1ApplicationWatchEvent
func (a *ApplicationServiceApiService) ApplicationServiceWatchExecute(r ApiApplicationServiceWatchRequest) (StreamResultOfV1alpha1ApplicationWatchEvent, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  StreamResultOfV1alpha1ApplicationWatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceWatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stream/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.refresh != nil {
		localVarQueryParams.Add("refresh", parameterToString(*r.refresh, ""))
	}
	if r.projects != nil {
		t := *r.projects
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("projects", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("projects", parameterToString(t, "multi"))
		}
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.selector != nil {
		localVarQueryParams.Add("selector", parameterToString(*r.selector, ""))
	}
	if r.repo != nil {
		localVarQueryParams.Add("repo", parameterToString(*r.repo, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	if r.project != nil {
		t := *r.project
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("project", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("project", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApplicationServiceWatchResourceTreeRequest struct {
	ctx _context.Context
	ApiService *ApplicationServiceApiService
	applicationName string
	namespace *string
	name *string
	version *string
	group *string
	kind *string
	appNamespace *string
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Namespace(namespace string) ApiApplicationServiceWatchResourceTreeRequest {
	r.namespace = &namespace
	return r
}
func (r ApiApplicationServiceWatchResourceTreeRequest) Name(name string) ApiApplicationServiceWatchResourceTreeRequest {
	r.name = &name
	return r
}
func (r ApiApplicationServiceWatchResourceTreeRequest) Version(version string) ApiApplicationServiceWatchResourceTreeRequest {
	r.version = &version
	return r
}
func (r ApiApplicationServiceWatchResourceTreeRequest) Group(group string) ApiApplicationServiceWatchResourceTreeRequest {
	r.group = &group
	return r
}
func (r ApiApplicationServiceWatchResourceTreeRequest) Kind(kind string) ApiApplicationServiceWatchResourceTreeRequest {
	r.kind = &kind
	return r
}
func (r ApiApplicationServiceWatchResourceTreeRequest) AppNamespace(appNamespace string) ApiApplicationServiceWatchResourceTreeRequest {
	r.appNamespace = &appNamespace
	return r
}

func (r ApiApplicationServiceWatchResourceTreeRequest) Execute() (StreamResultOfV1alpha1ApplicationTree, *_nethttp.Response, error) {
	return r.ApiService.ApplicationServiceWatchResourceTreeExecute(r)
}

/*
ApplicationServiceWatchResourceTree Watch returns stream of application resource tree

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param applicationName
 @return ApiApplicationServiceWatchResourceTreeRequest
*/
func (a *ApplicationServiceApiService) ApplicationServiceWatchResourceTree(ctx _context.Context, applicationName string) ApiApplicationServiceWatchResourceTreeRequest {
	return ApiApplicationServiceWatchResourceTreeRequest{
		ApiService: a,
		ctx: ctx,
		applicationName: applicationName,
	}
}

// Execute executes the request
//  @return StreamResultOfV1alpha1ApplicationTree
func (a *ApplicationServiceApiService) ApplicationServiceWatchResourceTreeExecute(r ApiApplicationServiceWatchResourceTreeRequest) (StreamResultOfV1alpha1ApplicationTree, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  StreamResultOfV1alpha1ApplicationTree
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ApplicationServiceApiService.ApplicationServiceWatchResourceTree")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/stream/applications/{applicationName}/resource-tree"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationName"+"}", _neturl.PathEscape(parameterToString(r.applicationName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.version != nil {
		localVarQueryParams.Add("version", parameterToString(*r.version, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.kind != nil {
		localVarQueryParams.Add("kind", parameterToString(*r.kind, ""))
	}
	if r.appNamespace != nil {
		localVarQueryParams.Add("appNamespace", parameterToString(*r.appNamespace, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RuntimeError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
